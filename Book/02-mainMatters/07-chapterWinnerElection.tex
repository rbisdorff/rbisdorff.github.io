\chapter{Computing the winner of an election}
\label{sec:7}

\abstract*{To be written.}

\abstract{To be written.}

\section{Linear voting profiles}
\label{sec:7.1}

The {\tt votingProfiles} module provides resources for handling election results \cite{ADT-L2}, like the \texttt{LinearVotingProfile} class. We consider an election involving a finite set of candidates and finite set of weighted voters, who express their voting preferences in a complete linear ranking (without ties) of the candidates. The data is internally stored in two ordered dictionaries, one for the voters and another one for the candidates. The linear ballots are stored in a standard dictionary.

\begin{lstlisting}[basicstyle=\footnotesize]
candidates = OrderedDict([('a1',...), ('a2',...), ('a3', ...), ...}
voters = OrderedDict([('v1',{'weight':10}), ('v2',{'weight':3}), ...}
## each voter specifies a linearly ranked list of candidates
## from the best to the worst (without ties
linearBallot = {
  'v1' : ['a2','a3','a1', ...],
  'v2' : ['a1','a2','a3', ...],
   ...
  }
\end{lstlisting}

The module provides a \texttt{RandomLinearVotingProfile} class for generating random instances of the \texttt{LinearVotingProfile} class. In an interactive Python session we may obtain for the election of 3 candidates by 5 voters the following result.

\begin{lstlisting}[caption={Example of random linear voting profile},label=list:7.1,basicstyle=\footnotesize]
>>> from votingProfiles import RandomLinearVotingProfile
>>> v = RandomLinearVotingProfile(numberOfVoters=5,\
...                               numberOfCandidates=3,\
...                               RandomWeights=True)
   
>>> v.candidates
 OrderedDict([ ('a1',{'name':'a1}), ('a2',{'name':'a2'}),
               ('a3',{'name':'a3'}) ])
>>> v.voters
 OrderedDict([('v1',{'weight': 2}), ('v2':{'weight': 3}), 
     ('v3',{'weight': 1}), ('v4':{'weight': 5}), 
     ('v5',{'weight': 4})])
>>> v.linearBallot
    {'v1': ['a1', 'a2', 'a3',],
     'v2': ['a3', 'a2', 'a1',],
     'v3': ['a1', 'a3', 'a2',],
     'v4': ['a1', 'a3', 'a2',],
     'v5': ['a2', 'a3', 'a1',]} 
 \end{lstlisting}

Notice that in this random example, the five voters are weighted (see Listing \ref{list:7.1} Line 6-7). Their linear ballots can be viewed with the \texttt{showLinearBallots} method.

\begin{lstlisting}[basicstyle=\footnotesize]
>>> v.showLinearBallots()
    voters(weight)	 candidates rankings
    v1(2): 	 ['a2', 'a1', 'a3']
    v2(3): 	 ['a3', 'a1', 'a2']
    v3(1): 	 ['a1', 'a3', 'a2']
    v4(5): 	 ['a1', 'a2', 'a3']
    v5(4): 	 ['a3', 'a1', 'a2']
    nbr. of voters: 15
\end{lstlisting}

Editing of the linear voting profile may be achieved by storing the data in a file, edit it, and reload it again.

\begin{lstlisting}[basicstyle=\footnotesize]
>>> v.save(fileName='tutorialLinearVotingProfile1')
 *--- Saving linear profile in file: <tutorialLinearVotingProfile1.py> ---*
>>> from votingProfiles import LinearVotingProfile
>>> v = LinearVotingProfile('tutorialLinearVotingProfile1')
\end{lstlisting}

\section{Computing the winner}
\label{sec:7.2}

We may easily compute \textbf{uni-nominal votes}, i.e. how many times a candidate was ranked first, and see who is consequently the \textbf{simple majority} winner(s) in this election.

\begin{lstlisting}[basicstyle=\footnotesize]
>>> v.computeUninominalVotes()
  {'a2': 2, 'a1': 6, 'a3': 7}
>>> v.computeSimpleMajorityWinner()
  ['a3']
\end{lstlisting}

As we observe no absolute majority (8/15) of votes for any of the three candidate, we may look for the \textbf{instant runoff} winner instead (see \cite{ADT-L2}).

\begin{lstlisting}[caption={Example Instant Run Off Winner},label=list:7.2,basicstyle=\footnotesize]
>>> v.computeInstantRunoffWinner(Comments=True)
  Half of the Votes =  7.50
    ==> stage =  1
	remaining candidates ['a1', 'a2', 'a3']
	uninominal votes {'a1': 6, 'a2': 2, 'a3': 7}
	minimal number of votes =  2
	maximal number of votes =  7
	candidate to remove =  a2
	remaining candidates =  ['a1', 'a3']
    ==> stage =  2
	remaining candidates ['a1', 'a3']
	uninominal votes {'a1': 8, 'a3': 7}
	minimal number of votes =  7
	maximal number of votes =  8
	candidate a1 obtains an absolute majority
   Instant run off winner: ['a1']
 \end{lstlisting}

In stage 1, no candidate obtains an absolute majority of votes. Candidate $a_2$ obtains the minimal number of votes (2/15) and is, hence, eliminated. In stage 2, candidate $a_1$ obtains an absolute majority of the votes (8/15) and is eventually elected (see Listing \ref{list:7.2}).

We may also follow the \emph{Chevalier de Borda}'s advice and, after a \textbf{rank analysis} of the linear ballots, compute the \textbf{Borda score} -the average rank- of each candidate and hence determine the \emph{Borda} \textbf{winner(s)}.

\begin{lstlisting}[caption={Example of \emph{Borda} rank scores},label=list:7.3,basicstyle=\footnotesize]
>>> v.computeRankAnalysis()
 {'a2': [2, 5, 8], 'a1': [6, 9, 0], 'a3': [7, 1, 7]}
>>> v.computeBordaScores()
 OrderedDict([
   ('a1', {'BordaScore': 24, 'averageBordaScore': 1.6}),
   ('a3', {'BordaScore': 30, 'averageBordaScore': 2.0}),
   ('a2', {'BordaScore': 36, 'averageBordaScore': 2.4}) ])
>>> v.computeBordaWinners()
 ['a1']
\end{lstlisting}

Candidate $a_1$ obtains the minimal \emph{Borda} score, followed by candidate $a_3$ and finally candidate $a_2$ (see Listing \ref{list:7.3}). The corresponding \emph{Borda} \textbf{rank analysis table} may be printed out with a corresponding \texttt{show} command.

\begin{lstlisting}[caption={Rank analysis example},label=list:7.4,basicstyle=\footnotesize]
>>> v.showRankAnalysisTable()
 *----  Borda rank analysis tableau -----*
  candi- | alternative-to-rank |     Borda
  dates  |   1     2     3     | score  average
  -------|-------------------------------------
   'a1'  |   6     9     0     | 24/15   1.60
   'a3'  |   7     1     7     | 30/15   2.00
   'a2'  |   2     5     8     | 36/15   2.40
 \end{lstlisting}

In our randomly generated election results, we are lucky: The instant runoff winner and the \emph{Borda} winner both is candidate $a_1$ (see Listings \ref{list:7.2} and \ref{list:7.3}). However, we could also follow the \emph{Marquis de Condorcet}'s advice, and compute the \textbf{majority margins} obtained by voting for each individual pair of candidates.

\section{The Condorcet winner}
\label{sec:7.3}

For instance, candidate $a_1$ is ranked four times before and once behind candidate $a_2$. Hence the corresponding \textbf{majority margin} $M(a_1,a_2)$ is $4 - 1 = +3$. These \emph{majority margins} define on the set of candidates what we call the \textbf{majority margins digraph}. The \texttt{MajorityMarginsDigraph} class (a specialization of the \texttt{Digraph} class) is available for handling such kind of digraphs.

\begin{lstlisting}[caption={Example of \emph{Majority Margins} digraph},label=list:7.5,basicstyle=\footnotesize]
>>> from votingProfiles import MajorityMarginsDigraph
>>> mmdg = MajorityMarginsDigraph(v,IntegerValuation=True)
>>> mmdg
 *------- Digraph instance description ------*
  Instance class      : MajorityMarginsDigraph
  Instance name       : rel_randomLinearVotingProfile1
  Digraph Order       : 3
  Digraph Size        : 3
  Valuation domain    : [-15.00;15.00]
  Determinateness (%) : 64.44
  Attributes          : ['name', 'actions', 'voters',
                           'ballot', 'valuationdomain',
			   'relation', 'order',
			   'gamma', 'notGamma']
>>> mmdg.showAll()
 *----- show detail -------------*
  Digraph          : rel_randLinearVotingProfile1
  *---- Actions ----*
   ['a1', 'a2', 'a3']
  *---- Characteristic valuation domain ----*
   {'max': Decimal('15.0'), 'med': Decimal('0'),
    'min': Decimal('-15.0'), 'hasIntegerValuation': True}
  * ---- majority margins -----
     M(x,y)   |  'a1'	'a2'  'a3'	  
    ----------|-------------------
      'a1'    |    0     11     1	 
      'a2'    |  -11      0    -1	 
      'a3'    |   -1      1     0	 
    Valuation domain: [-15;+15]
\end{lstlisting}

Notice that in the case of linear voting profiles, majority margins always verify a zero sum property: $M(x,y) + M(y,x) = 0$ for all candidates $x$ and $y$ (see Listing \ref{list:7.5} Lines 26-28). This is not true in general for arbitrary voting profiles. The \emph{majority margins} digraph of linear voting profiles defines in fact a \emph{weak tournament} and belongs, hence, to the class of \emph{self-codual} bipolar-valued digraphs\footnote{The class of self-codual bipolar-valued digraphs consists of all weakly asymmetric digraphs, i.e. digraphs containing only asymmetric and/or indeterminate links. Limit cases consists of, on the one side, full tournaments with indeterminate reflexive links, and, on the other side, fully indeterminate digraphs. In this class, the converse (inverse $\sim$) operator is indeed identical to the dual (negation $-$ ) one.}.
    
Now, a candidate $x$, showing a positive majority margin $M(x,y)$, is beating candidate $y$  with an absolute majority in a pairwise voting. Hence, a candidate showing only positive terms in her row in the \emph{majority margins} digraph relation table, beats all other candidates with absolute majority of votes. Condorcet recommends to declare this candidate (is always unique, why?) the winner of the election. Here we are lucky, it is again candidate $a_1$ who is hence the \textbf{Condorcet winner} (see Listing \ref{list:7.5} Line 26).

\begin{lstlisting}[basicstyle=\footnotesize]
>>> mmdg.computeCondorcetWinners()
 ['a1']  
\end{lstlisting}    

By seeing the majority margins like a \emph{bipolar-valued characteristic function} of a global preference relation defined on the set of candidates, we may use all operational resources of the generic \texttt{Digraph} class (see Chapter \ref{sec:2}), and especially its \texttt{exportGraphViz()} method \footnote{The \texttt{exportGraphViz()} method is depending on drawing tools from the graphviz software (https://graphviz.org/).}, for visualizing an election result.
\begin{lstlisting}[basicstyle=\footnotesize]
>>> mmdg.exportGraphViz(fileName='tutorialLinearBallots')
 *---- exporting a dot file for GraphViz tools ---------*
  Exporting to tutorialLinearBallots.dot
  dot -Grankdir=BT -Tpng tutorialLinearBallots.dot \
                   -o tutorialLinearBallots.png
\end{lstlisting}
\begin{figure}[h]
\sidecaption
\includegraphics[width=6cm]{Figures/tutorialLinearBallots.png}
\caption{Visualizing an election result. In the Figure we notice that the \emph{majority margins} digraph from our example linear voting profile gives a linear order of the candidates: $a_1 > a_3 > a_2$, the same actually as given by the \emph{Borda} scores (see Listing \ref{list:7.4}). This is by far not given in general. Usually, when aggregating linear ballots, there appear cyclic social preferences.
}
\label{fig:7.1}       % Give a unique label
\end{figure}

\section{Cyclic social preferences}
\label{sec:7.4}

Let us consider for instance the following linear voting profile and construct the corresponding majority margins digraph.

\begin{lstlisting}[caption={Example of cyclic social preferences},label=list:7.6,basicstyle=\footnotesize]
>>> v.showLinearBallots()
    voters(weight)	 candidates rankings
    v1(1): 	 ['a1', 'a3', 'a5', 'a2', 'a4']
    v2(1): 	 ['a1', 'a2', 'a4', 'a3', 'a5']
    v3(1): 	 ['a5', 'a2', 'a4', 'a3', 'a1']
    v4(1): 	 ['a3', 'a4', 'a1', 'a5', 'a2']
    v5(1): 	 ['a4', 'a2', 'a3', 'a5', 'a1']
    v6(1): 	 ['a2', 'a4', 'a5', 'a1', 'a3']
    v7(1): 	 ['a5', 'a4', 'a3', 'a1', 'a2']
    v8(1): 	 ['a2', 'a4', 'a5', 'a1', 'a3']
    v9(1): 	 ['a5', 'a3', 'a4', 'a1', 'a2']
>>> mmdg = MajorityMarginsDigraph(v)
>>> mmdg.showRelationTable()
    * ---- Relation Table -----
      S   |  'a1'   'a2'   'a3'	  'a4'	  'a5'	  
    ------|----------------------------------------
    'a1'  |   -     0.11  -0.11	 -0.56	 -0.33	 
    'a2'  | -0.11    -	   0.11	  0.11	 -0.11	 
    'a3'  |  0.11  -0.11    -	 -0.33	 -0.11	 
    'a4'  |  0.56  -0.11   0.33	   -	  0.11	 
    'a5'  |  0.33   0.11   0.11	 -0.11	   -	 
\end{lstlisting}    

Now, we cannot find any completely positive row in the relation table (see Listing \ref{list:7.6} Lines 17 - ). No one of the five candidates is beating all the others with an absolute majority of votes. There is no \emph{Condorcet} winner anymore. In fact, when looking at a graphviz drawing of this \emph{majority margins} digraph, we may observe \textbf{cyclic} preferences, like $(a_1 > a_2 > a_3 > a_1)$ for instance.

\begin{lstlisting}[basicstyle=\footnotesize]
>>> mmdg.exportGraphViz('cycles')
 *---- exporting a dot file for GraphViz tools ---------*
  Exporting to cycles.dot
  dot -Grankdir=BT -Tpng cycles.dot -o cycles.png
\end{lstlisting}

\begin{figure}[h]
\sidecaption
\includegraphics[width=4cm]{Figures/cycles.png}
\caption{Cyclic social preferences.}
\label{fig:7.2}       % Give a unique label
\end{figure}
	   
But, there may be many cycles appearing in a \emph{majority margins} digraph, and, we may detect and enumerate all minimal chordless circuits in a Digraph instance with the \texttt{computeChordlessCircuits} method.

\begin{lstlisting}[basicstyle=\footnotesize]
>>> mmdg.computeChordlessCircuits()
 [(['a2', 'a3', 'a1'], frozenset({'a2', 'a3', 'a1'})), 
  (['a2', 'a4', 'a5'], frozenset({'a2', 'a5', 'a4'})), 
  (['a2', 'a4', 'a1'], frozenset({'a2', 'a1', 'a4'}))]
\end{lstlisting}

\emph{Condorcet}'s approach for determining the winner of an election is hence \emph{not decisive} in all circumstances and we need to exploit more sophisticated approaches for finding the winner of the election on the basis of the majority margins of the given linear ballots (see Chapters \ref{sec:7}, \ref{sec:8} and [BIS-2008]). 

Many more tools for exploiting voting results are available like the browser heat map view on voting profiles. The number of voters is usually much larger than the number of candidates. In that case, it is better to generate a transposed \emph{voters} $\times$ \emph{candidates} view (see Line 2 below) 

\begin{lstlisting}[basicstyle=\footnotesize]
>>> v.showHTMLVotingHeatmap(rankingRule='NetFlows',
...                         Transposed=False)
\end{lstlisting}

\begin{figure}[h]
\sidecaption
\includegraphics[width=4cm]{Figures/votingHeatmap.png}
\caption{Visualizing a linear voting profile in a heatmap format. Notice that the importance weights of the voters are \emph{negative}, which means that the preference direction of the criteria (in this case the individual voters) is \emph{decreasing}, i.e. goes from lowest (best) rank to highest (worst) rank.
}
\label{fig:7.3}       % Give a unique label
\end{figure}

It worthwhile noticing that the compromise \emph{NetFlows} ranking $a_4 > a_5 > a_2 > a_1 > a_3$, shown in this heatmap (see Fig. \ref{fig:7.3}) results in an optimal \emph{ordinal correlation} index of $+0.778$ with the pairwise majority voting margins.
==>> (see Chapters on Ordinal Correlation equals Relational Equivalence and Ranking-Tutorial-label). 

\section{On generating realistic random linear voting profiles}
\label{sec:7.5}

By default, the \texttt{RandomLinearVotingProfile} class generates random linear voting profiles where every candidates has the same uniform probabilities to be ranked at a certain position by all the voters. Each voter's random linear ballot is indeed generated  via a uniform shuffling of the list of candidates.

In reality, political election data appear quite different. There usually will be different favorite and marginal candidates for each political party. To simulate these aspects into our random generator, we are using two random exponentially distributed polls of the candidates and consider a bipartisan political landscape with a certain random balance (default theoretical party repartition = $0.50$) between the two sets of potential party supporters. A certain theoretical proportion (default = $0.1$) will not support any party.

Let us generate such a linear voting profile for an election with $1000$ voters and $15$ candidates.

\begin{lstlisting}[caption={Generating a linear voting profile with random polls},label=list:7.7,basicstyle=\footnotesize]
>>> from votingProfiles import RandomLinearVotingProfile
>>> lvp = RandomLinearVotingProfile(\
...         numberOfCandidates=15,
...         numberOfVoters=1000,
...         WithPolls=True,
...         partyRepartition=0.5,
...         other=0.1,
...         seed=0.9189670954954139)

>>> lvp
 *------- VotingProfile instance description ------*
  Instance class : RandomLinearVotingProfile
  Instance name  : randLinearProfile
  Candidates     : 15
  Voters         : 1000
  Attributes     : ['name', 'seed', 'candidates',
            'voters', 'RandomWeights',
            'sumWeights', 'poll1', 'poll2',
            'bipartisan', 'linearBallot', 'ballot']
>>> lvp.showRandomPolls()
 Random repartition of voters
  Party_1 supporters : 460 (46.0%)
  Party_2 supporters : 436 (43.6%)
  Other voters       : 104 (10.4%)
 *---------------- random polls ---------------
   Party-1(46.0%) | Party-2(43.6%)|  expected  
  -----------------------------------------------
    a06 : 19.91%  | a11 : 22.94%  | a06 : 15.00%
    a07 : 14.27%  | a08 : 15.65%  | a11 : 13.08%
    a03 : 10.02%  | a04 : 15.07%  | a08 : 09.01%
    a13 : 08.39%  | a06 : 13.40%  | a07 : 08.79%
    a15 : 08.39%  | a03 : 06.49%  | a03 : 07.44%
    a11 : 06.70%  | a09 : 05.63%  | a04 : 07.11%
    a01 : 06.17%  | a07 : 05.10%  | a01 : 05.06%
    a12 : 04.81%  | a01 : 05.09%  | a13 : 05.04%
    a08 : 04.75%  | a12 : 03.43%  | a15 : 04.23%
    a10 : 04.66%  | a13 : 02.71%  | a12 : 03.71%
    a14 : 04.42%  | a14 : 02.70%  | a14 : 03.21%
    a05 : 04.01%  | a15 : 00.86%  | a09 : 03.10%
    a09 : 01.40%  | a10 : 00.44%  | a10 : 02.34%
    a04 : 01.18%  | a05 : 00.29%  | a05 : 01.97%
    a02 : 00.90%  | a02 : 00.21%  | a02 : 00.51%
\end{lstlisting}

In this example (see Listing \ref{list:7.7} Lines 18-), we obtain 460 Party-1 supporters ($46\%$), 436 Party-2 supporters ($43.6\%$) and 104 other voters ($10.4\%$). Favorite candidates of Party-1 supporters, with more than $10\%$, appear to be $a06$ ($19.91\%$), $a07$ ($14.27\%$) and $a03$ ($10.02\%$). Whereas for Party-2 supporters, favorite candidates appear to be $a11$ ($22.94\%$), followed by $a08$ ($15.65\%$), $a04$ ($15.07\%$) and $a06$ ($13.4\%$). Being \emph{first} choice for Party-1 supporters and \emph{fourth} choice for Party-2 supporters, this candidate $a06$ is a natural candidate for clearly winning this election game (see Listing \ref{list:7.8}).

\begin{lstlisting}[caption={The uninominal and \emph{Borda} election winner},label=list:7.8,basicstyle=\footnotesize]
>>> lvp.computeSimpleMajorityWinner()
 ['a06']
>>> lvp.computeInstantRunoffWinner()
 ['a06']  
>>> lvp.computeBordaWinners()
 ['a06']
\end{lstlisting}

Is it also a \emph{Condorcet} winner ? To verify, we start by creating the corresponding \emph{majority margins} digraph $mmdg$ with the help of the \texttt{MajorityMarginsDigraph} class. The created digraph instance contains 15 \emph{actions} -the candidates- and 105 \emph{oriented arcs} -the \emph{positive} majority margins- (see Listing \ref{list:7.9} Lines 7-8).

\begin{lstlisting}[caption={A majority margins digraph constructed from a linear voting profile},label=list:7.9,basicstyle=\footnotesize]
>>> from votingProfiles import MajorityMarginsDigraph
>>> mmdg = MajorityMarginsDigraph(lvp)
>>> mmdg
 *------- Digraph instance description ------*
  Instance class      : MajorityMarginsDigraph
  Instance name       : rel_randLinearProfile
  Digraph Order       : 15
  Digraph Size        : 104
  Valuation domain    : [-1000.00;1000.00]
  Determinateness (%) : 67.08
  Attributes          : ['name', 'actions', 'voters',
                         'ballot', 'valuationdomain',
                         'relation', 'order',
                         'gamma', 'notGamma']
\end{lstlisting}

We may visualize the resulting pairwise majority margins by showing the HTML formated version of the $mmdg$ relation table in a browser view.

\begin{lstlisting}[basicstyle=\footnotesize]
>>> cdg.showHTMLRelationTable(tableTitle='Pairwise majority margins',
...                           relationName='M(x>y)')
\end{lstlisting}

\begin{figure}[h]
\sidecaption
\includegraphics[width=4cm]{Figures/majorityMargins.png}
\caption{Browsing the majority margins. \emph{Light green} cells contain the positive majority margins, whereas \emph{light red} cells contain the negative majority margins.}
\label{fig:7.4}       % Give a unique label
\end{figure}

A complete \emph{light green} row reveals a \emph{Condorcet} \textbf{winner}, whereas a complete \emph{light green} column reveals a \emph{Condorcet} \textbf{loser}. We recover again candidate $a06$ as \emph{Condorcet} winner\footnote{The concept of \Condorcet winner --a generalization of absolute majority winners-- proposed by \Condorcet in 1785, is an early historical example of initial digraph kernel (see Chapter \ref{sec:17})}.), whereas the obvious \emph{Condorcet} loser is here candidate $a02$, the candidate with the lowest support in both parties (see Listing \ref{list:7.7} Line 40).

With a same \emph{bipolar-first ranked} and \emph{last ranked} candidate- selection procedure, we may \emph{weakly rank} the candidates (with possible ties) by iterating these \emph{first ranked} and \emph{last ranked} choices among the remaining candidates ([BIS-1999]).

\begin{lstlisting}[caption={Ranking by iterating choosing the \emph{first} and \emph{last} remaining candidates },label=list:7.10,basicstyle=\footnotesize]
>>> cdg.showRankingByChoosing()
 Error: You must first run
  self.computeRankingByChoosing(CoDual=False(default)|True) !
>>> cdg.computeRankingByChoosing()
>>> cdg.showRankingByChoosing()
 Ranking by Choosing and Rejecting
   1st first ranked ['a06']
     2nd first ranked ['a11']
       3rd first ranked ['a07', 'a08']
         4th first ranked ['a03']
           5th first ranked ['a01']
             6th first ranked ['a13']
               7th first ranked ['a04']
               7th last ranked ['a12']
	     6th last ranked ['a14']
	   5th last ranked ['a15']
	 4th last ranked ['a09']
       3rd last ranked ['a10']
     2nd last ranked ['a05']
   1st last ranked ['a02']
\end{lstlisting}
 
Before showing the \emph{ranking-by-choosing} result, we have to compute the iterated bipolar selection procedure (see Listing \ref{list:7.10} Line 2). The first selection concerns $a06$ (first) and $a02$ (last), followed by $a11$ (first) opposed to $a05$ (last), and so on, until there remains at iteration step 7 a last pair of candidates, namely $[a04, a12]$ (see Lines 13-14).

Notice furthermore the first ranked candidates at iteration step 3 (see Line 9), namely the pair $(a07, a08)$. Both candidates represent indeed conjointly the \emph{first ranked} choice. We obtain here hence a \emph{weak ranking}, i.e. a ranking with a tie.

Let us mention that the \emph{instant-run-off} procedure, we used before (see Listing \ref{list:7.8} Line 3), when operated with a \texttt{Comments=True} parameter setting, will deliver a more or less similar \emph{reversed} linear \emph{ordering-by-rejecting} result, namely [$a02$, $a10$, $a14$, $a05$, $a09$, $a13$, $a12$, $a15$, $a04$, $a01$, $a08$, $a03$, $a07$, $a11$, $a06$], ordered from the \emph{last} to the \emph{first} choice.

Remarkable about both these \emph{ranking-by-choosing} or \emph{ordering-by-rejecting} results is the fact that the random voting behaviour, simulated here with the help of two discrete random variables \footnote{Discrete random variables with a given empirical probability law (here the polls) are provided in the \texttt{randomNumbers} module by the \texttt{DiscreteRandomVariable} class.}, defined respectively by the two party polls, is rendering a ranking that is more or less in accordance with the simulated balance of the polls: -Party-1 supporters : 460;  Party-2 supporters: 436 (see Listing \ref{list:7.7} Lines 26-40 third column). Despite a random voting behaviour per voter, the given polls apparently show a \emph{very strong incidence} on the eventual election result. In order to avoid any manipulation of the election outcome, public media are therefore in some countries not allowed to publish polls during the last weeks before a general election.

Mind that the specific \emph{ranking-by-choosing} procedure, we use here on the \emph{majority margins} digraph, operates the selection procedure by extracting at each step \emph{initial} and \emph{terminal} kernels, i.e. NP-hard operational problems (see tutorial on kernels and \cite{BIS-1999}); A technique that does not allow in general to tackle voting profiles with much more than 30 candidates. The tutorial on ranking methods provides more adequate and efficient techniques for ranking from pairwise majority margins when a larger number of potential candidates is given.  
