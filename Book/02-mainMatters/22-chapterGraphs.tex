\chapter{Working with undirected graphs}
\label{sec:22}

\abstract*{}

\abstract{}

\section{Implementing undirected graphs}
\label{sec:22.1}

In the \Digraph {\tt graphs} module, the root \texttt{Graph} class provides a generic simple graph model, without loops and multiple links. A given object of this class contains at least the following attributes in:
\begin{enumerate}
\item \texttt{vertices}: a dictionary of vertices with \texttt{name} and \texttt{shortName} attributes,
\item \texttt{edges} : a dictionary with \emph{frozensets} \footnote{\href{https://docs.python.org/3.9/library/stdtypes.html?highlight=frozenset\#frozenset}{Python documentation}} of pairs of vertices as entries carrying a characteristic value in the range of the previous valuation domain,
\item \texttt{valuationDomain}: a dictionary with three entries: the minimum ($-1$, means certainly no link), the median ($0$, means missing information) and the maximum characteristic value ($+1$, means certainly a link),
\item \texttt{gamma}: a dictionary containing the direct neighbors of each vertex, automatically added by the object constructor.
\end{enumerate}

Example Python3 session:
\begin{lstlisting}
>>> from graphs import Graph
>>> g = Graph(numberOfVertices=7,edgeProbability=0.5)
>>> g.save(fileName='tutorialGraph')
\end{lstlisting}

The saved \texttt{Graph} instance named \texttt{tutorialGraph.py} is encoded as follows.
\begin{lstlisting}
    # Graph instance saved in Python format
    vertices = {
    'v1': {'shortName': 'v1', 'name': 'random vertex'},
    'v2': {'shortName': 'v2', 'name': 'random vertex'},
    'v3': {'shortName': 'v3', 'name': 'random vertex'},
    'v4': {'shortName': 'v4', 'name': 'random vertex'},
    'v5': {'shortName': 'v5', 'name': 'random vertex'},
    'v6': {'shortName': 'v6', 'name': 'random vertex'},
    'v7': {'shortName': 'v7', 'name': 'random vertex'},
    }
    valuationDomain = {'min':-1,'med':0,'max':1}
    edges = {
    frozenset(['v1','v2']) : -1, 
    frozenset(['v1','v3']) : -1, 
    frozenset(['v1','v4']) : -1, 
    frozenset(['v1','v5']) : 1, 
    frozenset(['v1','v6']) : -1, 
    frozenset(['v1','v7']) : -1, 
    frozenset(['v2','v3']) : 1, 
    frozenset(['v2','v4']) : 1, 
    frozenset(['v2','v5']) : -1, 
    frozenset(['v2','v6']) : 1, 
    frozenset(['v2','v7']) : -1, 
    frozenset(['v3','v4']) : -1, 
    frozenset(['v3','v5']) : -1, 
    frozenset(['v3','v6']) : -1, 
    frozenset(['v3','v7']) : -1, 
    frozenset(['v4','v5']) : 1, 
    frozenset(['v4','v6']) : -1, 
    frozenset(['v4','v7']) : 1, 
    frozenset(['v5','v6']) : 1, 
    frozenset(['v5','v7']) : -1, 
    frozenset(['v6','v7']) : -1, 
    }
\end{lstlisting}

The stored graph can be reloaded and plotted with the generic \\
\texttt{exportGraphViz()} Footnote[1] method as follows:
\begin{lstlisting}
>>> g = Graph('tutorialGraph')
>>> g.exportGraphViz()
  *---- exporting a dot file for GraphViz tools ---------*
   Exporting to tutorialGraph.dot
   fdp -Tpng tutorialGraph.dot -o tutorialGraph.png
\end{lstlisting}
\begin{figure}[h]
\sidecaption
\includegraphics[width=7cm]{Figures/tutorialGraph.png}
\caption{Example simple graph instance} 
\label{fig:22.1}       % Give a unique label
\end{figure}

Properties, like the gamma function and vertex degrees and neighbourhood depths may be shown with a \texttt{showShort()} method.
\begin{lstlisting}
>>> g.showShort()
  *---- short description of the graph ----*
   Name : 'tutorialGraph'
   Vertices :  ['v1','v2','v3','v4','v5','v6','v7']
   Valuation domain : {'min': -1, 'med': 0, 'max': 1}
   Gamma function   : 
    v1 -> ['v5']
    v2 -> ['v6', 'v4', 'v3']
    v3 -> ['v2']
    v4 -> ['v5', 'v2', 'v7']
    v5 -> ['v1', 'v6', 'v4']
    v6 -> ['v2', 'v5']
    v7 -> ['v4']
   degrees      :  [0, 1, 2, 3, 4, 5, 6]
   distribution :  [0, 3, 1, 3, 0, 0, 0]
   nbh depths   :  [0, 1, 2, 3, 4, 5, 6, 'inf.']
   distribution :  [0, 0, 1, 4, 2, 0, 0, 0]
\end{lstlisting}

A \texttt{Graph} instance corresponds bijectively to a symmetric \texttt{Digraph} instance and we may easily convert from one to the other with the \texttt{graph2Digraph()}, and vice versa with the \texttt{digraph2Graph()} method. Thus, all computing resources of the \texttt{Digraph} class, suitable for symmetric digraphs, become readily available, and vice versa.
\begin{lstlisting}
>>> dg = g.graph2Digraph()
>>> dg.showRelationTable(ndigits=0,ReflexiveTerms=False)
  * ---- Relation Table -----
    S  |  'v1'  'v2'  'v3'  'v4'  'v5'  'v6'  'v7'	  
  -----|------------------------------------------
  'v1' |    -    -1    -1    -1     1    -1    -1	 
  'v2' |   -1     -     1     1    -1     1    -1	 
  'v3' |   -1     1     -    -1    -1    -1    -1	 
  'v4' |   -1     1    -1     -     1    -1     1	 
  'v5' |    1    -1    -1     1     -     1    -1	 
  'v6' |   -1     1    -1    -1     1     -    -1	 
  'v7' |   -1    -1    -1     1    -1    -1     -
>>> g1 = dg.digraph2Graph()
>>> g1.showShort()
  *---- short description of the graph ----*
   Name         : 'tutorialGraph'
   Vertices     :  ['v1','v2','v3','v4','v5','v6','v7']
   Valuation domain :   {'med': 0, 'min': -1, 'max': 1}
   Gamma function   : 
    v1 -> ['v5']
    v2 -> ['v3', 'v6', 'v4']
    v3 -> ['v2']
    v4 -> ['v5', 'v7', 'v2']
    v5 -> ['v6', 'v1', 'v4']
    v6 -> ['v5', 'v2']
    v7 -> ['v4']
   degrees      :  [0, 1, 2, 3, 4, 5, 6]
   distribution :  [0, 3, 1, 3, 0, 0, 0]
   nbh depths   :  [0, 1, 2, 3, 4, 5, 6, 'inf.']
   distribution :  [0, 0, 1, 4, 2, 0, 0, 0]
\end{lstlisting}

\section{q-coloring of a graph}
\label{25.2}

A 3-coloring of the tutorial graph $g$ may for instance be computed and plotted with the \texttt{Q\_Coloring} class as follows.
\begin{lstlisting}
>>> from graphs import Q_Coloring
>>> qc = Q_Coloring(g)
  Running a Gibbs Sampler for 42 step !
  The q-coloring with 3 colors is feasible !!
>>> qc.showConfiguration()
    v5 lightblue
    v3 gold
    v7 gold
    v2 lightblue
    v4 lightcoral
    v1 gold
    v6 lightcoral
>>> qc.exportGraphViz('tutorial-3-coloring')
  *---- exporting a dot file for GraphViz tools
   Exporting to tutorial-3-coloring.dot
   fdp -Tpng tutorial-3-coloring.dot\
                    -o tutorial-3-coloring.png
\end{lstlisting}
\begin{figure}[h]
\sidecaption
\includegraphics[width=7cm]{Figures/tutorial-3-coloring.png}
\caption{3-Coloring of the tutorial graph} 
\label{fig:22.2}       % Give a unique label
\end{figure}

Actually, with the given tutorial graph instance, a 2-coloring is already feasible.
\begin{lstlisting}
>>> qc = Q_Coloring(g,colors=['gold','coral'])
  Running a Gibbs Sampler for 42 step !
  The q-coloring with 2 colors is feasible !!
>>> qc.showConfiguration()
    v5 gold
    v3 coral
    v7 gold
    v2 gold
    v4 coral
    v1 coral
    v6 coral
>>> qc.exportGraphViz('tutorial-2-coloring')
  Exporting to tutorial-2-coloring.dot
  fdp -Tpng tutorial-2-coloring.dot\
                    -o tutorial-2-coloring.png
\end{lstlisting}
\begin{figure}[h]
\sidecaption
\includegraphics[width=7cm]{Figures/tutorial-2-coloring.png}
\caption{3-Coloring of the tutorial graph} 
\label{fig:22.3}       % Give a unique label
\end{figure}

\section{MIS and clique enumeration}
\label{sec:22.3}

2-colorings define independent sets of vertices that are maximal in cardinality. Computing such MISs in a given \texttt{Graph} instance may be achieved by the \texttt{showMIS} method.
\begin{lstlisting}
>>> g = Graph('tutorialGraph')
>>> g.showMIS()
  *---  Maximal Independent Sets ---*
    ['v2', 'v5', 'v7']
    ['v3', 'v5', 'v7']
    ['v1', 'v2', 'v7']
    ['v1', 'v3', 'v6', 'v7']
    ['v1', 'v3', 'v4', 'v6']
    number of solutions:  5
    cardinality distribution
    card.:  [0, 1, 2, 3, 4, 5, 6, 7]
    freq.:  [0, 0, 0, 3, 2, 0, 0, 0]
    execution time: 0.00032 sec.
    Results in self.misset
>>> g.misset
    [frozenset({'v7', 'v2', 'v5'}), 
     frozenset({'v3', 'v7', 'v5'}), 
     frozenset({'v1', 'v2', 'v7'}), 
     frozenset({'v1', 'v6', 'v7', 'v3'}), 
     frozenset({'v1', 'v6', 'v4', 'v3'})]
\end{lstlisting}

A MIS in the dual of a graph instance $g$, corresponds to a maximal \emph{clique}, i.e. a maximal complete subgraph in $g$. Maximal cliques may be directly enumerated with the \texttt{showCliques()} method.
\begin{lstlisting}
>>> g.showCliques()
  *---  Maximal Cliques ---*
    ['v2', 'v3']
    ['v4', 'v7']
    ['v2', 'v4']
    ['v4', 'v5']
    ['v1', 'v5']
    ['v2', 'v6']
    ['v5', 'v6']
   number of solutions:  7
   cardinality distribution
   card.:  [0, 1, 2, 3, 4, 5, 6, 7]
   freq.:  [0, 0, 7, 0, 0, 0, 0, 0]
   execution time: 0.00049 sec.
   Results in self.cliques
>>> g.cliques
  [frozenset({'v2', 'v3'}), frozenset({'v4', 'v7'}), 
   frozenset({'v2', 'v4'}), frozenset({'v4', 'v5'}), 
   frozenset({'v1', 'v5'}), frozenset({'v6', 'v2'}), 
   frozenset({'v6', 'v5'})]
\end{lstlisting}

\section{Line graphs and maximal matchings}
\label{sec:22.4}

The \texttt{graphs} module also provides a \texttt{LineGraph} constructor. A \emph{line graph} represents the adjacencies between edges of the given graph instance. We may compute for instance the line graph of the 5-cycle graph.
\begin{lstlisting}
>>> from graphs import CycleGraph, LineGraph
>>> g = CycleGraph(order=5)
>>> g
  *------- Graph instance description ----*
   Instance class   : CycleGraph
   Instance name    : cycleGraph
   Graph Order      : 5
   Graph Size       : 5
   Valuation domain : [-1.00; 1.00]
   Attributes       : ['name', 'order',
             'vertices', 'valuationDomain',
             'edges', 'size', 'gamma']
>>> lg = LineGraph(g)
>>> lg
  *------- Graph instance description ------*
   Instance class   : LineGraph
   Instance name    : line-cycleGraph
   Graph Order      : 5
   Graph Size       : 5
   Valuation domain : [-1.00; 1.00]
   Attributes       : ['name', 'graph',
              'valuationDomain', 'vertices',
               'order', 'edges', 'size', 'gamma']
>>> lg.showShort()
  *---- short description of the graph ----*
   Name             : 'line-cycleGraph'
   Vertices         :  [frozenset({'v1', 'v2'}),
        frozenset({'v1', 'v5'}), frozenset({'v2', 'v3'}),
        frozenset({'v3', 'v4'}), frozenset({'v4', 'v5'})]
   Valuation domain :  {'min': Decimal('-1'),
                'med': Decimal('0'), 'max': Decimal('1')}
   Gamma function   : 
    frozenset({'v1', 'v2'}) ->
         [frozenset({'v2', 'v3'}), frozenset({'v1', 'v5'})]
    frozenset({'v1', 'v5'}) ->
         [frozenset({'v1', 'v2'}), frozenset({'v4', 'v5'})]
    frozenset({'v2', 'v3'}) ->
         [frozenset({'v1', 'v2'}), frozenset({'v3', 'v4'})]
    frozenset({'v3', 'v4'}) ->
         [frozenset({'v2', 'v3'}), frozenset({'v4', 'v5'})]
    frozenset({'v4', 'v5'}) ->
         [frozenset({'v4', 'v3'}), frozenset({'v1', 'v5'})]
   degrees      :  [0, 1, 2, 3, 4]
   distribution :  [0, 0, 5, 0, 0]
   nbh depths   :  [0, 1, 2, 3, 4, 'inf.']
   distribution :  [0, 0, 5, 0, 0, 0]
\end{lstlisting}

Iterated line graph constructions are usually expanding, except for chordless cycles, where the same cycle is repeated, and for non-closed paths, where iterated line graphs progressively reduce one by one the number of vertices and edges and become eventually an empty graph.

Notice that the MISs in the line graph provide \emph{maximal matchings} --maximal sets of independent edges-- of the original graph.
\begin{lstlisting}[basicstyle=\scriptsize]
>>> c8 = CycleGraph(order=8)
>>> lc8 = LineGraph(c8)
>>> lc8.showMIS()
  *---  Maximal Independent Sets ---*
    [frozenset({'v3', 'v4'}), frozenset({'v5', 'v6'}), frozenset({'v1', 'v8'})]
    [frozenset({'v2', 'v3'}), frozenset({'v5', 'v6'}), frozenset({'v1', 'v8'})]
    [frozenset({'v8', 'v7'}), frozenset({'v2', 'v3'}), frozenset({'v5', 'v6'})]
    [frozenset({'v8', 'v7'}), frozenset({'v2', 'v3'}), frozenset({'v4', 'v5'})]
    [frozenset({'v7', 'v6'}), frozenset({'v3', 'v4'}), frozenset({'v1', 'v8'})]
    [frozenset({'v2', 'v1'}), frozenset({'v8', 'v7'}), frozenset({'v4', 'v5'})]
    [frozenset({'v2', 'v1'}), frozenset({'v7', 'v6'}), frozenset({'v4', 'v5'})]
    [frozenset({'v2', 'v1'}), frozenset({'v7', 'v6'}), frozenset({'v3', 'v4'})]
    [frozenset({'v7', 'v6'}), frozenset({'v2', 'v3'}), frozenset({'v1', 'v8'}),
     frozenset({'v4', 'v5'})]
    [frozenset({'v2', 'v1'}), frozenset({'v8', 'v7'}), frozenset({'v3', 'v4'}),
     frozenset({'v5', 'v6'})]
    number of solutions:  10
    cardinality distribution
    card.:  [0, 1, 2, 3, 4, 5, 6, 7, 8]
    freq.:  [0, 0, 0, 8, 2, 0, 0, 0, 0]
    execution time: 0.00029 sec.
\end{lstlisting}
The two last MISs of cardinality 4 (see Lines 13-16 above) give isomorphic perfect maximum matchings of the 8-cycle graph. Every vertex of the cycle is adjacent to a matching edge. Odd cycle graphs do not admit any perfect matching.
\begin{lstlisting}
>>> maxMatching = c8.computeMaximumMatching()
>>> c8.exportGraphViz(fileName='maxMatchingcycleGraph',\
...   		      matching=maxMatching)
  *---- exporting a dot file for GraphViz tools -----*
   Exporting to maxMatchingcyleGraph.dot
   Matching:  {frozenset({'v1', 'v2'}),
               frozenset({'v5', 'v6'}),
               frozenset({'v3', 'v4'}),
               frozenset({'v7', 'v8'}) }
   circo -Tpng maxMatchingcyleGraph.dot\
                  -o maxMatchingcyleGraph.png
\end{lstlisting}
\begin{figure}[h]
\sidecaption
\includegraphics[width=7cm]{Figures/maxMatchingcycleGraph.png}
\caption{A perfect maximum matching of the 8-cycle graph} 
\label{fig:22.4}       % Give a unique label
\end{figure}
	    
\section{Grids and the Ising model}
\label{sec:22.5}

Special classes of graphs, like $n \times m$ rectangular or triangular grids (\texttt{GridGraph} and \texttt{IsingModel}) are available from the \texttt{graphs} module. For instance, we may use a \emph{Gibbs} sampler again for simulating an \emph{Ising Model} on such a grid.
\begin{lstlisting}
>>> from graphs import GridGraph, IsingModel
>>> g = GridGraph(n=15,m=15)
>>> g.showShort()
  *----- show short --------------*
   Grid graph    :  grid-6-6
   n             :  6
   m             :  6
   order         :  36
>>> im = IsingModel(g,beta=0.3,nSim=100000,Debug=False)
  Running a Gibbs Sampler for 100000 step !
>>> im.exportGraphViz(colors=['lightblue','lightcoral'])
  *---- exporting a dot file for GraphViz tools ---------*
   Exporting to grid-15-15-ising.dot
   fdp -Tpng grid-15-15-ising.dot -o grid-15-15-ising.png
\end{lstlisting}
\begin{figure}[h]
\sidecaption
\includegraphics[width=11cm]{Figures/grid-15-15-ising.png}
\caption{Ising model of the 15x15 grid graph} 
\label{fig:22.5}       % Give a unique label
\end{figure}

\section{Simulating Metropolis random walks}
\label{sec:22.6}

Finally, we provide the \texttt{MetropolisChain} class, a specialization of the \texttt{Graph} class, for implementing a generic \emph{Metropolis} Monte Carlo Markov Chain (MCMC) sampler for simulating random walks on a given graph $g$:
\begin{lstlisting}
>>> from graphs import Graph
>>> g = Graph(numberOfVertices=5,edgeProbability=0.5)
>>> g.showShort()
  *---- short description of the graph ----*
   Name             : 'randomGraph'
   Vertices         :  ['v1', 'v2', 'v3', 'v4', 'v5']
   Valuation domain :  {'max': 1, 'med': 0, 'min': -1}
   Gamma function   :
    v1 -> ['v2', 'v3', 'v4']
    v2 -> ['v1', 'v4']
    v3 -> ['v5', 'v1']
    v4 -> ['v2', 'v5', 'v1']
    v5 -> ['v3', 'v4']
\end{lstlisting}
following a given probability $probs$ = \{‘v1’: $x$, ‘v2’: $y$, ...\} for visiting each vertex:
\begin{lstlisting}
>>> probs = {}  # initialize a potential stationary probability vector 
>>> n = g.order # for instance: probs[v_i] = n-i/Sum(1:n) for i in 1:n
>>> i = 0
>>> verticesList = [x for x in g.vertices]
>>> verticesList.sort()
>>> for v in verticesList:
...     probs[v] = (n - i)/(n*(n+1)/2)
...     i += 1
\end{lstlisting}

The \texttt{checkSampling()} method of the the \texttt{MetropolisChain} class (see below) generates a random walk of $nSim = 30000$ steps on the given graph and records by the way the observed relative frequency with which each vertex is passed by:
\begin{lstlisting}
>>> from graphs import MetropolisChain     
>>> met = MetropolisChain(g,probs)
>>> frequency = met.checkSampling(verticesList[0],nSim=30000)
>>> for v in verticesList:
...     print(v,probs[v],frequency[v])   
    v1 0.3333 0.3343
    v2 0.2666 0.2680
    v3 0.2    0.2030
    v4 0.1333 0.1311
    v5 0.0666 0.0635
\end{lstlisting}
  In this example, the stationary transition probability distribution (see Listing above), shown by the \texttt{showTransitionMatrix()} method below is quite adequately simulated.
\begin{lstlisting}
>>> met.showTransitionMatrix()
  * ---- Transition Matrix -----
    Pij  | 'v1'    'v2'    'v3'    'v4'    'v5'
    -----|-------------------------------------
    'v1' |  0.23   0.33    0.30    0.13    0.00
    'v2' |  0.42   0.42    0.00    0.17    0.00
    'v3' |  0.50   0.00    0.33    0.00    0.17
    'v4' |  0.33   0.33    0.00    0.08    0.25
    'v5' |  0.00   0.00    0.50    0.50    0.00
\end{lstlisting}

For the reader interested in algorithmic applications of Markov Chains we may recommend consulting O. Häggström's 2002 book: [FMCAA].
 
